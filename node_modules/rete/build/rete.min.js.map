{"version":3,"file":"rete.min.js","sources":["../src/engine/component.ts","../src/node.ts","../src/component.ts","../src/connection.ts","../src/control.ts","../src/core/emitter.ts","../src/io.ts","../src/input.ts","../src/core/validator.ts","../src/core/context.ts","../src/view/drag.js","../src/view/zoom.js","../src/view/area.ts","../src/view/connection.ts","../src/view/control.ts","../src/view/socket.ts","../src/view/node.ts","../src/view/index.ts","../src/selected.ts","../src/core/events.ts","../src/events.ts","../src/editor.ts","../src/output.ts","../src/socket.ts","../src/engine/recursion.ts","../src/engine/state.ts","../src/engine/events.ts","../src/engine/index.ts","../src/index.ts"],"sourcesContent":["import { Engine } from './index';\nimport { Node } from '../core/data';\n\nexport interface IOs { [key: string]: any }\n\nexport abstract class Component {\n\n    name: string;\n    data = {};\n    engine: Engine | null = null;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    abstract worker(node: Node, inputs: IOs, outputs: IOs, ...args: any): any;\n}","import { Connection } from './connection';\nimport { Control } from './control';\nimport { Input } from './input';\nimport { Node as NodeData } from './core/data';\nimport { Output } from './output';\n\nexport class Node {\n\n    name: string;\n    id: number;\n    position: [number, number] = [0.0, 0.0];\n    inputs = new Map<string, Input>();\n    outputs = new Map<string, Output>();\n    controls = new Map<string, Control>();\n    data: any = {};\n    meta: any = {};\n\n    static latestId = 0;\n    \n    constructor(name: string) {\n        this.name = name;\n        this.id = Node.incrementId();\n    }\n\n    _add(list: Map<string, any>, item: any, prop: string) {\n        if (list.has(item.key))\n            throw new Error(`Item with key '${item.key}' already been added to the node`);\n        if (item[prop] !== null)\n            throw new Error('Item has already been added to some node');\n        \n        item[prop] = this;\n        list.set(item.key, item);\n    }\n\n    addControl(control: Control) {\n        this._add(this.controls, control, 'parent');\n        return this;\n    }\n\n    removeControl(control: Control) {\n        control.parent = null;\n\n        this.controls.delete(control.key);\n    }\n\n    addInput(input: Input) {\n        this._add(this.inputs, input, 'node');\n        return this;\n    }\n\n    removeInput(input: Input) {\n        input.removeConnections();\n        input.node = null;\n\n        this.inputs.delete(input.key);\n    }\n\n    addOutput(output: Output) {\n        this._add(this.outputs, output, 'node');\n        return this;\n    }\n\n    removeOutput(output: Output) {\n        output.removeConnections();\n        output.node = null;\n\n        this.outputs.delete(output.key);\n    }\n\n    getConnections() {\n        const ios = [...this.inputs.values(), ...this.outputs.values()];\n        const connections = ios.reduce((arr, io) => {\n            return [...arr, ...io.connections];\n        }, [] as Connection[]);\n\n        return connections;\n    }\n\n    update() {}\n\n    static incrementId() {\n        if (!this.latestId)\n            this.latestId = 1\n        else\n            this.latestId++\n        return this.latestId\n    }\n\n    static resetId() {\n        this.latestId = 0;\n    }\n\n    toJSON() {\n        const reduceIO = (list: Map<string, Input | Output>) => {\n            return Array.from(list).reduce((obj, [key, io]) => { obj[key] = io.toJSON(); return obj; }, {} as any)\n        }\n\n        return {\n            'id': this.id,\n            'data': this.data,\n            'inputs': reduceIO(this.inputs),\n            'outputs': reduceIO(this.outputs),\n            'position': this.position,\n            'name': this.name\n        }\n    }\n\n    static fromJSON(json: NodeData) {\n        const node = new Node(json.name);\n        const [x, y] = json.position;\n\n        node.id = json.id;\n        node.data = json.data;\n        node.position = [x, y];\n        node.name = json.name;\n        Node.latestId = Math.max(node.id, Node.latestId);\n\n        return node;\n    }\n}\n","import { Component as ComponentWorker } from './engine/component';\nimport { Node } from './node';\n\nexport abstract class Component extends ComponentWorker {\n\n    editor: any = null;\n    data: any = {};\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    abstract async builder(node: Node): Promise<any>;\n\n    async build(node: Node) {\n        await this.builder(node);\n\n        return node;\n    }\n\n    async createNode(data = {}) {\n        const node = new Node(this.name);\n        \n        node.data = data;\n        await this.build(node);\n\n        return node;\n    }\n}","import { Input } from './input';\nimport { Output } from './output';\n\nexport class Connection {\n\n    output: Output;\n    input: Input;\n    data: any = {};\n\n    constructor(output: Output, input: Input) {\n        this.output = output;\n        this.input = input;\n        this.data = {};\n\n        this.input.addConnection(this);\n    }\n\n    remove() {\n        this.input.removeConnection(this);\n        this.output.removeConnection(this);\n    }\n}","import { Input } from './input';\nimport { Node } from './node';\n\nexport class Control {\n\n    key: string;\n    data: any = {};\n    parent: Node | Input | null = null;\n\n    constructor(key: string) {\n        if (this.constructor === Control)\n            throw new TypeError('Can not construct abstract class');\n        if (!key)\n            throw new Error('The key parameter is missing in super() of Control ');\n\n        this.key = key;\n    }\n\n    getNode() {\n        if (this.parent === null)\n            throw new Error('Control isn\\'t added to Node/Input');   \n        \n        if (this.parent instanceof Node)\n            return this.parent;\n            \n        if (!this.parent.node)\n            throw new Error('Control hasn\\'t be added to Input or Node');\n\n        return this.parent.node;\n    }\n\n    getData(key: string) {\n        return this.getNode().data[key];\n    }\n\n    putData(key: string, data: any) {\n        this.getNode().data[key] = data;\n    }  \n}","import { Events } from './events';\n\nexport class Emitter<EventTypes> {\n\n    events: any = {};\n    silent = false;\n\n    constructor(events: Events | Emitter<EventTypes>) {\n        this.events = events instanceof Emitter ? events.events : events.handlers;\n    }\n\n    on<K extends keyof EventTypes>(names: K | K[], handler: (args: EventTypes[K]) => any) {\n        const events = names instanceof Array ? names : (names as string).split(' ');\n\n        (events as string[]).forEach(name => {\n            if (!this.events[name])\n                throw new Error(`The event ${name} does not exist`);\n            this.events[name].push(handler);\n        });\n\n        return this;\n    }\n\n    trigger<K extends keyof EventTypes>(name: K, params: EventTypes[K] | {} = {}) {\n        if (!(name in this.events))\n            throw new Error(`The event ${name} cannot be triggered`);\n\n        return this.events[name].reduce((r: boolean, e: Function) => {\n            return (e(params) !== false) && r\n        }, true); // return false if at least one event is false        \n    }\n\n    bind(name: string) {\n        if (this.events[name])\n            throw new Error(`The event ${name} is already bound`);\n\n        this.events[name] = [];\n    }\n\n    exist(name: string) {\n        return Array.isArray(this.events[name]);\n    }\n}","import { Connection } from './connection';\nimport { Node } from './node';\nimport { Socket } from './socket';\n\nexport class IO {\n\n    node: Node | null = null;\n    multipleConnections: boolean;\n    connections: Connection[] = [];\n   \n    key: string;\n    name: string;\n    socket: Socket;\n\n    constructor(key: string, name: string, socket: Socket, multiConns: boolean) {\n\t    this.node = null;\n        this.multipleConnections = multiConns;\n        this.connections = [];\n\t   \n        this.key = key;\n        this.name = name;\n        this.socket = socket;\n    }\n    \n    removeConnection(connection: Connection) {\n        this.connections.splice(this.connections.indexOf(connection), 1);\n    }\n\n    removeConnections() {\n        this.connections.map(connection => this.removeConnection(connection));\n    }\n}","import { Connection } from './connection';\nimport { Control } from './control';\nimport { IO } from './io';\nimport { Socket } from './socket';\n\nexport class Input extends IO {\n   \n    control: Control | null = null;\n\n    constructor(key: string, title: string, socket: Socket, multiConns: boolean = false) {\n        super(key, title, socket, multiConns);\n    }\n\n    hasConnection() {\n        return this.connections.length > 0;\n    }\n\n    addConnection(connection: Connection) {\n        if (!this.multipleConnections && this.hasConnection())\n            throw new Error('Multiple connections not allowed');\n        this.connections.push(connection);\n    }\n\n    addControl(control: Control) {\n        this.control = control;\n        control.parent = this;\n    }\n\n    showControl() {\n        return !this.hasConnection() && this.control !== null;\n    }\n\n    toJSON() {\n        return {\n            'connections': this.connections.map(c => {\n                return {\n                    node: c.output.node && c.output.node.id,\n                    output: c.output.key,\n                    data: c.data\n                };\n            })\n        };\n    }\n}","import { Data } from './data';\n\nexport class Validator {\n\n    static isValidData(data: Data) {\n        return typeof data.id === 'string' &&\n            this.isValidId(data.id) &&\n            data.nodes instanceof Object && !(data.nodes instanceof Array);\n    }\n\n    static isValidId(id: string) {\n        return /^[\\w-]{3,}@[0-9]+\\.[0-9]+\\.[0-9]+$/.test(id);\n    }\n\n    static validate(id: string, data: Data) {\n        const id1 = id.split('@');\n        const id2 = data.id.split('@');\n        let msg = [];\n\n        if (!this.isValidData(data))\n            msg.push('Data is not suitable'); \n        if (id !== data.id)\n            msg.push('IDs not equal');\n        if (id1[0] !== id2[0])\n            msg.push('Names don\\'t match');\n        if (id1[1] !== id2[1])\n            msg.push('Versions don\\'t match');\n\n        return { success: Boolean(!msg.length), msg: msg.join('. ') };\n    }\n}","import { Component } from '../engine/component';\nimport { Emitter } from './emitter'\nimport { Validator } from './validator'\nimport { EventsTypes as DefaultEvents, Events } from './events';\nimport { Plugin, PluginParams } from './plugin';\n\nexport class Context<EventsTypes> extends Emitter<EventsTypes & DefaultEvents> {\n\n    id: string;\n    plugins: Map<string, any>;\n    components: Map<string, Component>;\n\n    constructor(id: string, events: Events) {\n        super(events);\n\n        if (!Validator.isValidId(id))\n            throw new Error('ID should be valid to name@0.1.0 format');  \n        \n        this.id = id;\n        this.plugins = new Map();\n        this.components = new Map();\n    }\n\n    use<T extends Plugin, O extends PluginParams<T>>(plugin: T, options?: O) {\n        if (plugin.name && this.plugins.has(plugin.name)) throw new Error(`Plugin ${plugin.name} already in use`)\n\n        plugin.install(this, options || {});\n        this.plugins.set(plugin.name, options)\n    }\n\n    register(component: Component) {\n        if (this.components.has(component.name))\n            throw new Error(`Component ${component.name} already registered`);\n\n        this.components.set(component.name, component);\n        this.trigger('componentregister', component);\n    }\n\n    destroy() {\n        this.trigger('destroy');\n    }\n}","export class Drag {\n\n    constructor(el, onTranslate = () => {}, onStart = () => {}, onDrag = () => {}) {\n        this.pointerStart = null;\n\n        this.el = el;\n        this.onTranslate = onTranslate;\n        this.onStart = onStart;\n        this.onDrag = onDrag;\n\n        this.initEvents(el);\n    }\n\n    initEvents(el) {\n        el.style.touchAction = 'none';\n\n        el.addEventListener('pointerdown', this.down.bind(this));\n        window.addEventListener('pointermove', this.move.bind(this));\n        window.addEventListener('pointerup', this.up.bind(this));\n    }\n\n    down(e) {\n        e.stopPropagation();\n        this.pointerStart = [e.pageX, e.pageY]\n\n        this.onStart(e);\n    }\n\n    move(e) {\n        if (!this.pointerStart) return;\n        e.preventDefault();\n\n        let [x, y] = [e.pageX, e.pageY]\n\n        let delta = [x - this.pointerStart[0], y - this.pointerStart[1]];\n\n        let zoom = this.el.getBoundingClientRect().width / this.el.offsetWidth;\n\n        this.onTranslate(delta[0] / zoom, delta[1] / zoom, e);\n    }\n\n    up(e) {\n        if (!this.pointerStart) return;\n        \n        this.pointerStart = null;\n        this.onDrag(e);\n    }\n}","export class Zoom {\n\n    constructor(container, el, intensity, onzoom) {\n        this.el = el;\n        this.intensity = intensity;\n        this.onzoom = onzoom;\n\n        this.distance = null;\n\n        container.addEventListener('wheel', this.wheel.bind(this));\n        container.addEventListener('touchmove', this.move.bind(this));\n        container.addEventListener('touchend', this.end.bind(this));\n        container.addEventListener('touchcancel', this.end.bind(this));\n        container.addEventListener('dblclick', this.dblclick.bind(this));\n    }\n\n    wheel(e) {\n        e.preventDefault();\n        \n        const rect = this.el.getBoundingClientRect();\n        const delta = (e.wheelDelta ? e.wheelDelta / 120 : - e.deltaY / 3) * this.intensity;\n\n        const ox = (rect.left - e.clientX) * delta;\n        const oy = (rect.top - e.clientY) * delta;\n\n        this.onzoom(delta, ox, oy, 'wheel');\n    }\n\n    touches(e) {\n        let [x1, y1] = [e.touches[0].clientX, e.touches[0].clientY];\n\n        let [x2, y2] = [e.touches[1].clientX, e.touches[1].clientY];\n\n        let distance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n\n        return {\n            cx: (x1 + x2)/2,\n            cy: (y1 + y2)/2,\n            distance\n        };\n    }\n\n    move(e) {\n        if (e.touches.length < 2) return;\n        \n        let rect = this.el.getBoundingClientRect();\n\n        let { cx, cy, distance } = this.touches(e);\n\n        if (this.distance !== null) {\n            let delta = distance / this.distance - 1;\n    \n            const ox = (rect.left - cx) * delta;\n            const oy = (rect.top - cy) * delta;\n\n            this.onzoom(delta, ox, oy, 'touch');\n        }\n        this.distance = distance;\n    }\n\n    end() {\n        this.distance = null;\n    }\n\n    dblclick(e) {\n        e.preventDefault();\n        \n        const rect = this.el.getBoundingClientRect();\n        const delta = 4 * this.intensity;\n\n        const ox = (rect.left - e.clientX) * delta;\n        const oy = (rect.top - e.clientY) * delta;\n\n        this.onzoom(delta, ox, oy, 'dblclick'); \n    }\n}","import { Drag } from './drag';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { Zoom } from './zoom';\n\nexport interface Transform { k: number; x: number; y: number }\nexport interface Mouse { x: number; y: number }\nexport type ZoomSource = 'wheel' | 'touch' | 'dblclick';\n\nexport class Area extends Emitter<EventsTypes> {\n\n    el: HTMLElement;\n    container: HTMLElement;\n    transform: Transform = { k: 1, x: 0, y: 0 };\n    mouse: Mouse = { x: 0, y: 0 }\n\n    private _startPosition: any = null\n\n    constructor(container: HTMLElement, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        \n        const el = this.el = document.createElement('div');\n\n        this.container = container;\n        el.style.transformOrigin = '0 0';\n\n        new Zoom(container, el, 0.1, this.onZoom.bind(this));\n        new Drag(container, this.onTranslate.bind(this) as any, this.onStart.bind(this));\n        this.container.addEventListener('pointermove', this.pointermove.bind(this));\n\n        this.update();\n    }\n\n    update() {\n        const t = this.transform;\n\n        this.el.style.transform = `translate(${t.x}px, ${t.y}px) scale(${t.k})`;\n    }\n\n    pointermove(e: PointerEvent) {\n        const { clientX, clientY } = e;\n        const rect = this.el.getBoundingClientRect();\n        const x = clientX - rect.left;\n        const y = clientY - rect.top;\n        const k = this.transform.k;\n        \n        this.mouse = { x: x / k, y: y / k };\n        this.trigger('mousemove', { ...this.mouse }); // TODO rename on `pointermove`\n    }\n\n    onStart() {\n        this._startPosition = { ...this.transform };\n    }\n\n    onTranslate(dx: number, dy: number) {\n        this.translate(this._startPosition.x + dx, this._startPosition.y + dy)\n    }\n\n    onZoom(delta: number, ox: number, oy: number, source: ZoomSource) {\n        this.zoom(this.transform.k * (1 + delta), ox, oy, source);\n\n        this.update();\n    }\n\n    translate(x: number, y: number) {\n        const params = { transform: this.transform, x, y };\n\n        if (!this.trigger('translate', params)) return;\n\n        this.transform.x = params.x;\n        this.transform.y = params.y;\n\n        this.update();\n        this.trigger('translated');\n    }\n\n    zoom(zoom: number, ox = 0, oy = 0, source: ZoomSource) {\n        const k = this.transform.k;\n        const params = { transform: this.transform, zoom, source };\n\n        if (!this.trigger('zoom', params)) return;\n        \n        const d = (k - params.zoom) / ((k - zoom) || 1);\n\n        this.transform.k = params.zoom || 1;\n        this.transform.x += ox * d;\n        this.transform.y += oy * d;\n\n        this.update();\n        this.trigger('zoomed', { source });\n    }\n\n    appendChild(el: HTMLElement) {\n        this.el.appendChild(el)\n    }\n\n    removeChild(el: HTMLElement) {\n        this.el.removeChild(el)\n    }\n}","import { Connection } from '../connection';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { NodeView } from './node';\n\nexport class ConnectionView extends Emitter<EventsTypes> {\n\n    connection: Connection;\n    inputNode: NodeView;\n    outputNode: NodeView;\n    el: HTMLElement;\n\n    constructor(connection: Connection, inputNode: NodeView, outputNode: NodeView, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.connection = connection;\n        this.inputNode = inputNode;\n        this.outputNode = outputNode;\n\n        this.el = document.createElement('div');\n        this.el.style.position = 'absolute';\n        this.el.style.zIndex = '-1';\n\n        this.trigger('renderconnection', { \n            el: this.el, \n            connection: this.connection, \n            points: this.getPoints()\n        });\n    }\n\n    getPoints() {\n        const [x1, y1] = this.outputNode.getSocketPosition(this.connection.output);\n        const [x2, y2] = this.inputNode.getSocketPosition(this.connection.input);\n\n        return [x1, y1, x2, y2];\n    }\n\n    update() {\n        this.trigger('updateconnection', { \n            el: this.el, \n            connection: this.connection, \n            points: this.getPoints()\n        });\n    }\n}","import { Control } from '../control';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\n\nexport class ControlView extends Emitter<EventsTypes> {\n\n    constructor(el: HTMLElement, control: Control, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.trigger('rendercontrol', { el, control });\n    }\n}","import { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { IO } from '../io';\nimport { Node } from '../node';\n\nexport class SocketView extends Emitter<EventsTypes> {\n\n    el: HTMLElement;\n    type: string;\n    io: IO;\n    node: Node;\n\n    constructor(el: HTMLElement, type: string, io: IO, node: Node, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n        this.el = el;\n        this.type = type;\n        this.io = io;\n        this.node = node;\n\n        this.trigger('rendersocket', { el, [type]: this.io, socket: io.socket });\n    }\n\n    getPosition({ position }: { position: number[] }): [number, number] {\n        const el = this.el;\n\n        return [\n            position[0] + el.offsetLeft + el.offsetWidth / 2,\n            position[1] + el.offsetTop + el.offsetHeight / 2\n        ]\n    }\n}","import { Component } from '../engine/component';\nimport { Control } from '../control';\nimport { ControlView } from './control';\nimport { Drag } from './drag';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { IO } from '../io';\nimport { Node } from '../node';\nimport { SocketView } from './socket';\n\nexport class NodeView extends Emitter<EventsTypes> {\n\n    node: Node;\n    component: Component;\n    sockets = new Map<IO, SocketView>();\n    controls = new Map<Control, ControlView>();\n\n    el: HTMLElement;\n    private _startPosition: number[] = [];\n\n    constructor(node: Node, component: Component, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n\n        this.node = node;\n        this.component = component;\n        this.el = document.createElement('div');\n        this.el.style.position = 'absolute';\n\n        this.el.addEventListener('contextmenu', e => this.trigger('contextmenu', { e, node: this.node }));\n\n        new Drag(this.el, this.onTranslate.bind(this) as any, this.onSelect.bind(this) as any, () => {\n            this.trigger('nodedraged', node);\n        });\n\n        this.trigger('rendernode', {\n            el: this.el, \n            node, \n            component: component.data, \n            bindSocket: this.bindSocket.bind(this),\n            bindControl: this.bindControl.bind(this)\n        });\n\n        this.update();\n    }\n\n    clearSockets() {\n        const ios: IO[] = [ ...this.node.inputs.values(), ...this.node.outputs.values()];\n        \n        this.sockets.forEach(s => {\n            if (!ios.includes(s.io)) this.sockets.delete(s.io);\n        });\n    }\n\n    bindSocket(el: HTMLElement, type: string, io: IO) {\n        this.clearSockets();\n        this.sockets.set(io, new SocketView(el, type, io, this.node, this));\n    }\n\n    bindControl(el: HTMLElement, control: Control) {\n        this.controls.set(control, new ControlView(el, control, this));\n    }\n\n    getSocketPosition(io: IO) {\n        const socket = this.sockets.get(io);\n\n        if (!socket) throw new Error(`Socket not fount for ${io.name} with key ${io.key}`);\n\n        return socket.getPosition(this.node);\n    }\n\n    onSelect(e: MouseEvent) {        \n        this.onStart();\n        this.trigger('selectnode', { node: this.node, accumulate: e.ctrlKey });\n    }\n\n    onStart() {\n        this._startPosition = [...this.node.position];\n    }\n\n    onTranslate(dx: number, dy: number) {\n        this.trigger('translatenode', { node: this.node, dx, dy });\n    }\n\n    onDrag(dx: number, dy: number) {\n        const x = this._startPosition[0] + dx;\n        const y = this._startPosition[1] + dy;\n\n        this.translate(x, y);\n    }\n\n    translate(x: number, y: number) {\n        const node = this.node;\n        const params = { node, x, y };\n\n        if (!this.trigger('nodetranslate', params)) return;\n\n        const prev = [...node.position];\n\n        node.position[0] = params.x;\n        node.position[1] = params.y;\n\n        this.update();\n        this.trigger('nodetranslated', { node, prev });\n    }\n\n    update() {\n        const [x, y] = this.node.position;\n\n        this.el.style.transform = `translate(${x}px, ${y}px)`;\n    }\n\n    remove() {\n        \n    }\n}","import { Area } from './area';\nimport { Component } from '../engine/component';\nimport { Connection } from '../connection';\nimport { ConnectionView } from './connection';\nimport { Emitter } from '../core/emitter';\nimport { EventsTypes } from '../events';\nimport { Node } from '../node';\nimport { NodeView } from './node';\n\nexport class EditorView extends Emitter<EventsTypes> {\n\n    container: HTMLElement;\n    components: Map<string, Component>;\n    nodes = new Map<Node, NodeView>();\n    connections = new Map<Connection, ConnectionView>();\n    area: Area;\n\n    constructor(container: HTMLElement, components: Map<string, Component>, emitter: Emitter<EventsTypes>) {\n        super(emitter);\n\n        this.container = container;\n        this.components = components;\n\n        this.container.style.overflow = 'hidden';\n\n        this.container.addEventListener('click', this.click.bind(this));\n        this.container.addEventListener('contextmenu', e => this.trigger('contextmenu', { e, view: this }));\n        window.addEventListener('resize', this.resize.bind(this));\n\n        this.on('nodetranslated', this.updateConnections.bind(this));\n            \n        this.area = new Area(container, this);\n        this.container.appendChild(this.area.el);\n    }\n\n    addNode(node: Node) {\n        const component = this.components.get(node.name);\n\n        if (!component) throw new Error(`Component ${node.name} not found`);\n        \n        const nodeView = new NodeView(node, component, this);\n\n        this.nodes.set(node, nodeView);\n        this.area.appendChild(nodeView.el);\n    }\n\n    removeNode(node: Node) {\n        const nodeView = this.nodes.get(node);\n\n        this.nodes.delete(node);\n        if (nodeView)\n            this.area.removeChild(nodeView.el);\n    }\n\n    addConnection(connection: Connection) {\n        if (!connection.input.node || !connection.output.node)\n            throw new Error('Connection input or output not added to node');\n\n        const viewInput = this.nodes.get(connection.input.node);\n        const viewOutput = this.nodes.get(connection.output.node);\n\n        if (!viewInput || !viewOutput)\n            throw new Error('View node not fount for input or output');\n\n        const connView = new ConnectionView(connection, viewInput, viewOutput, this);\n\n        this.connections.set(connection, connView);\n        this.area.appendChild(connView.el);\n    }\n\n    removeConnection(connection: Connection) {\n        const connView = this.connections.get(connection);\n\n        this.connections.delete(connection);\n        if (connView)\n            this.area.removeChild(connView.el);\n    }\n\n    updateConnections({ node }: { node: Node }) {\n        node.getConnections().map(conn => {\n            let connView = this.connections.get(conn);\n\n            if (!connView) throw new Error('Connection view not found');\n\n            connView.update();\n        });\n    }\n\n    resize() {\n        const { container } = this;\n\n        if (!container.parentElement)\n            throw new Error('Container doesn\\'t have parent element');\n\n        const width = container.parentElement.clientWidth;\n        const height = container.parentElement.clientHeight;\n\n        container.style.width = width + 'px';\n        container.style.height = height + 'px';\n    }\n\n    click(e: Event) {\n        const container = this.container;\n        \n        if (container !== e.target) return;\n        if (!this.trigger('click', { e, container })) return;\n    }\n}\n","import { Node } from './node';\n\nexport class Selected {\n\n    list: Node[] = [];\n\n    add(item: Node, accumulate = false) {\n        if (!accumulate)\n            this.list = [item]; \n        else if (!this.contains(item))\n            this.list.push(item);   \n    }\n\n    clear() {\n        this.list = [];\n    }\n\n    remove(item: Node) {\n        this.list.splice(this.list.indexOf(item), 1);\n    }\n\n    contains(item: Node) {\n        return this.list.indexOf(item) !== -1;\n    }\n\n    each(callback: (n: Node, index: number) => any) {\n        this.list.forEach(callback);\n    }\n}","import { Component } from '../engine/component';\n\nexport class Events {\n\n    handlers: {};\n\n    constructor(handlers: {}) {\n        this.handlers = {\n            warn: [console.warn],\n            error: [console.error],\n            componentregister: [],\n            destroy: [],\n            ...handlers\n        }\n    }\n}\n\nexport interface EventsTypes {\n    warn: string | Error;\n    error: string | Error;\n    componentregister: Component;\n    destroy: void;\n}","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Control } from './control';\nimport { Data } from './core/data';\nimport { EditorView } from './view';\nimport { Events } from './core/events';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { Output } from './output';\nimport { Socket } from './socket';\nimport { Mouse, Transform, ZoomSource } from './view/area';\n\nexport class EditorEvents extends Events {\n\n    constructor() {\n        super({\n            nodecreate: [],\n            nodecreated: [],\n            noderemove: [],\n            noderemoved: [],\n            connectioncreate: [],\n            connectioncreated: [],\n            connectionremove: [],\n            connectionremoved: [],\n            translatenode: [],\n            nodetranslate: [],\n            nodetranslated: [],\n            nodedraged: [],\n            selectnode: [],\n            nodeselect: [],\n            nodeselected: [],\n            rendernode: [],\n            rendersocket: [],\n            rendercontrol: [],\n            renderconnection: [],\n            updateconnection: [],\n            keydown: [],\n            keyup: [],\n            translate: [],\n            translated: [],\n            zoom: [],\n            zoomed: [],\n            click: [],\n            mousemove: [],\n            contextmenu: [],\n            import: [],\n            export: [],\n            process: []\n        });\n    }    \n}\n\nexport interface EventsTypes {\n    componentregister: Component;\n    nodecreate: Node;\n    nodecreated: Node;\n    noderemove: Node;\n    noderemoved: Node;\n    connectioncreate: { input: Input; output: Output };\n    connectioncreated: Connection;\n    connectionremove: Connection;\n    connectionremoved: Connection;\n    translatenode: { node: Node; dx: number; dy: number };\n    nodetranslate: { node: Node; x: number; y: number };\n    nodetranslated: { node: Node; prev: [number, number] };\n    nodedraged: Node;\n    selectnode: {\n        node: Node;\n        accumulate: boolean;\n    };\n    nodeselect: Node;\n    nodeselected: Node;\n    rendernode: {\n        el: HTMLElement;\n        node: Node;\n        component: object;\n        bindSocket: Function;\n        bindControl: Function;\n    };\n    rendersocket: {\n        el: HTMLElement;\n        input?: Input;\n        output?: Output;\n        socket: Socket;\n    };\n    rendercontrol: {\n        el: HTMLElement;\n        control: Control;\n    };\n    renderconnection: {\n        el: HTMLElement;\n        connection: Connection;\n        points: number[];\n    };\n    updateconnection: {\n        el: HTMLElement;\n        connection: Connection;\n        points: number[];\n    };\n    keydown: KeyboardEvent;\n    keyup: KeyboardEvent;\n    translate: {\n        transform: Transform;\n        x: number;\n        y: number;\n    };\n    translated: void;\n    zoom: {\n        transform: Transform;\n        zoom: number;\n        source: ZoomSource;\n    };\n    zoomed: {\n        source: ZoomSource;\n    };\n    click: {\n        e: Event;\n        container: HTMLElement;\n    };\n    mousemove: Mouse;\n    contextmenu: {\n        e: MouseEvent;\n        view?: EditorView;\n        node?: Node;\n    };\n    import: Data;\n    export: Data;\n    process: void;\n}","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Context } from './core/context';\nimport { Data } from './core/data';\nimport { EditorView } from './view/index';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { Output } from './output';\nimport { Selected } from './selected';\nimport { Validator } from './core/validator';\nimport { EditorEvents, EventsTypes } from './events';\n\nexport class NodeEditor extends Context<EventsTypes> {\n\n    nodes: Node[] = [];\n    selected = new Selected();\n    view: EditorView;\n\n    constructor(id: string, container: HTMLElement) {\n        super(id, new EditorEvents());\n        \n        this.view = new EditorView(container, this.components, this);\n\n        window.addEventListener('keydown', e => this.trigger('keydown', e));\n        window.addEventListener('keyup', e => this.trigger('keyup', e));\n        this.on('selectnode', ({ node, accumulate }) => this.selectNode(node, accumulate));\n        this.on('nodeselected', () => this.selected.each(n => {\n            const nodeView = this.view.nodes.get(n);\n\n            nodeView && nodeView.onStart()\n        }));\n        this.on('translatenode', ({ dx, dy }) => this.selected.each(n => {\n            const nodeView = this.view.nodes.get(n);\n\n            nodeView && nodeView.onDrag(dx, dy)\n        }));\n    }\n\n    addNode(node: Node) {\n        if (!this.trigger('nodecreate', node)) return;\n\n        this.nodes.push(node);\n        this.view.addNode(node);\n        \n        this.trigger('nodecreated', node);\n    }\n\n    removeNode(node: Node) {\n        if (!this.trigger('noderemove', node)) return;\n\n        node.getConnections().forEach(c => this.removeConnection(c));\n\n        this.nodes.splice(this.nodes.indexOf(node), 1);\n        this.view.removeNode(node);\n\n        this.trigger('noderemoved', node);\n    }\n\n    connect(output: Output, input: Input, data = {}) {\n        if (!this.trigger('connectioncreate', { output, input })) return;\n\n        try {\n            const connection = output.connectTo(input);\n\n            connection.data = data;\n            this.view.addConnection(connection);\n\n            this.trigger('connectioncreated', connection);\n        } catch (e) {\n            this.trigger('warn', e)\n        }\n    }\n\n    removeConnection(connection: Connection) {\n        if (!this.trigger('connectionremove', connection)) return;\n            \n        this.view.removeConnection(connection);\n        connection.remove();\n\n        this.trigger('connectionremoved', connection);\n    }\n\n    selectNode(node: Node, accumulate: boolean = false) {\n        if (this.nodes.indexOf(node) === -1) \n            throw new Error('Node not exist in list');\n        \n        if (!this.trigger('nodeselect', node)) return;\n\n        this.selected.add(node, accumulate);\n        \n        this.trigger('nodeselected', node);\n    }\n\n    getComponent(name: string) {\n        const component = this.components.get(name);\n\n        if (!component)\n            throw `Component ${name} not found`;\n        \n        return component as Component;\n    }\n\n    register(component: Component) {\n        super.register(component)\n        component.editor = this;\n    }\n\n    clear() {\n        [...this.nodes].map(node => this.removeNode(node));\n    }\n\n    toJSON() {\n        const data: Data = { id: this.id, nodes: {} };\n        \n        this.nodes.forEach(node => data.nodes[node.id] = node.toJSON());\n        this.trigger('export', data);\n        return data;\n    }\n\n    beforeImport(json: Data) {\n        const checking = Validator.validate(this.id, json);\n        \n        if (!checking.success) {\n            this.trigger('warn', checking.msg);\n            return false;\n        }\n        \n        this.silent = true;\n        this.clear();\n        this.trigger('import', json);\n        return true;\n    }\n\n    afterImport() {\n        this.silent = false;\n        return true;\n    }\n\n    async fromJSON(json: Data) {\n        if (!this.beforeImport(json)) return false;\n        const nodes: any = {};\n\n        try {\n            await Promise.all(Object.keys(json.nodes).map(async id => {\n                const node = json.nodes[id];\n                const component = this.getComponent(node.name);\n\n                nodes[id] = await component.build(Node.fromJSON(node));\n                this.addNode(nodes[id]);\n            }));\n        \n            Object.keys(json.nodes).forEach(id => {\n                const jsonNode = json.nodes[id];\n                const node = nodes[id];\n                \n                Object.keys(jsonNode.outputs).forEach(key => {\n                    const outputJson = jsonNode.outputs[key];\n\n                    outputJson.connections.forEach(jsonConnection => {\n                        const nodeId = jsonConnection.node;\n                        const data = jsonConnection.data;\n                        const targetOutput = node.outputs.get(key);\n                        const targetInput = nodes[nodeId].inputs.get(jsonConnection.input);\n\n                        this.connect(targetOutput, targetInput, data);\n                    });\n                });\n\n            });\n        }\n        catch (e) {\n            this.trigger('warn', e);\n            return !this.afterImport();\n        } finally {\n            return this.afterImport();\n        }\n    }\n}\n","import { Connection } from './connection';\nimport { IO } from './io';\nimport { Input } from './input';\nimport { Socket } from './socket';\n\nexport class Output extends IO {\n  \n    constructor(key: string, title: string, socket: Socket, multiConns: boolean = true) {\n        super(key, title, socket, multiConns);\n    }\n    \n    hasConnection() {\n        return this.connections.length > 0;\n    }\n\n    connectTo(input: Input) {\n        if (!this.socket.compatibleWith(input.socket))\n            throw new Error('Sockets not compatible');\n        if (!input.multipleConnections && input.hasConnection())\n            throw new Error('Input already has one connection');\n        if (!this.multipleConnections && this.hasConnection())\n            throw new Error('Output already has one connection');\n\n        const connection = new Connection(this, input);\n\n        this.connections.push(connection);\n        return connection;\n    }\n\n    connectedTo(input: Input) {\n        return this.connections.some((item) => {\n            return item.input === input;\n        });\n    }\n\n    toJSON() {\n        return {\n            'connections': this.connections.map(c => {\n                return {\n                    node: c.input.node && c.input.node.id,\n                    input: c.input.key,\n                    data: c.data\n                }\n            })\n        };\n    }\n}","export class Socket {\n\n    name: string;\n    data: any;\n    compatible: Socket[] = [];\n\n    constructor(name: string, data = {}) {\n        this.name = name;\n        this.data = data;\n        this.compatible = [];\n    }\n\n    combineWith(socket: Socket) {\n        this.compatible.push(socket);\n    }\n\n    compatibleWith(socket: Socket) {\n        return this === socket || this.compatible.includes(socket);\n    }\n}","import { Node, Nodes } from '../core/data';\n\nfunction intersect(array1: any[], array2: any[]) {\n    return array1.filter(value => -1 !== array2.indexOf(value));\n}\n\nexport class Recursion {\n\n    nodes: Nodes;\n\n    constructor(nodes: Nodes) {\n        this.nodes = nodes;\n    }\n    \n    extractInputNodes(node: Node): Node[] {\n        return Object.keys(node.inputs).reduce((a: any[], key: string) => {\n            const { connections } = node.inputs[key];\n\n            return [...a, ...(connections || []).reduce((b: any[], c: any) => [...b, this.nodes[c.node]], [])]\n        }, []);\n    }\n\n    findSelf(list: any[], inputNodes: Node[]): Node | null {\n        const inters = intersect(list, inputNodes);\n\n        if (inters.length)\n            return inters[0];\n        \n        for (let node of inputNodes) {\n            let l = [node, ...list];\n            let inter = this.findSelf(l, this.extractInputNodes(node));\n\n            if (inter)\n                return inter;\n        }\n\n        return null;\n    }\n\n    detect(): Node | null {\n        const nodesArr = Object.keys(this.nodes).map(id => this.nodes[id]);\n\n        for (let node of nodesArr) {\n            let inters = this.findSelf([node], this.extractInputNodes(node));\n\n            if (inters)\n                return inters;\n        }\n\n        return null;\n    }\n}","export const State = { AVAILABLE: 0, PROCESSED: 1, ABORT: 2 }","import { Events } from '../core/events';\n\nexport class EngineEvents extends Events {\n\n    constructor() {\n        super({});\n    }    \n}\nexport interface EventsTypes {\n}","import { Component } from './component';\nimport { Context } from '../core/context';\nimport { Recursion } from './recursion';\nimport { State } from './state';\nimport { Validator } from '../core/validator';\nimport { Data, Node } from '../core/data';\nimport { EngineEvents, EventsTypes } from './events';\n\nexport { Component, Recursion };\n\ninterface EngineNode extends Node {\n    busy: boolean;\n    unlockPool: any[];\n    outputData: any;\n}\n\nexport class Engine extends Context<EventsTypes> {\n\n    args: any[] = [];\n    data: Data | null = null;\n    state = State.AVAILABLE;\n    onAbort = () => { };\n\n    constructor(id: string) {\n        super(id, new EngineEvents());\n    }\n\n    public clone() {\n        const engine = new Engine(this.id);\n\n        this.components.forEach(c => engine.register(c));\n\n        return engine;\n    }\n\n    async throwError (message: string, data: any = null) {\n        await this.abort();\n        this.trigger('error', { message, data });\n        this.processDone();\n\n        return 'error';\n    }\n\n    private processStart() {\n        if (this.state === State.AVAILABLE) {  \n            this.state = State.PROCESSED;\n            return true;\n        }\n\n        if (this.state === State.ABORT) {\n            return false;\n        }\n\n        console.warn(`The process is busy and has not been restarted.\n                Use abort() to force it to complete`);\n        return false;\n    }\n\n    private processDone() {\n        const success = this.state !== State.ABORT;\n\n        this.state = State.AVAILABLE;\n        \n        if (!success) {\n            this.onAbort();\n            this.onAbort = () => { }\n        }    \n\n        return success;\n    }\n\n    public async abort() {\n        return new Promise(ret => {\n            if (this.state === State.PROCESSED) {\n                this.state = State.ABORT;\n                this.onAbort = ret;\n            }\n            else if (this.state === State.ABORT) {\n                this.onAbort();\n                this.onAbort = ret;\n            }\n            else\n                ret();\n        });\n    }\n\n    private async lock(node: EngineNode) {\n        return new Promise(res => {\n            node.unlockPool = node.unlockPool || [];\n            if (node.busy && !node.outputData)\n                node.unlockPool.push(res);\n            else \n                res();\n            \n            node.busy = true;\n        });    \n    }\n\n    unlock(node: EngineNode) {\n        node.unlockPool.forEach(a => a());\n        node.unlockPool = [];\n        node.busy = false;\n    }\n\n    private async extractInputData(node: Node) {\n        const obj: {[id: string]: any} = {};\n\n        for (let key of Object.keys(node.inputs)) {\n            const input = node.inputs[key];\n            const conns = input.connections;\n            const connData = await Promise.all(conns.map(async (c) => {\n                const prevNode = (this.data as Data).nodes[c.node];\n\n                const outputs = await this.processNode(prevNode as EngineNode);\n\n                if (!outputs) \n                    this.abort();\n                else\n                    return outputs[c.output];\n            }));\n\n            obj[key] = connData;\n        }\n\n        return obj;\n    }\n\n    private async processWorker(node: Node) {\n        const inputData = await this.extractInputData(node);\n        const component = this.components.get(node.name) as Component;\n        const outputData = {};\n\n        try {\n            await component.worker(node, inputData, outputData, ...this.args);\n        } catch (e) {\n            this.abort();\n            this.trigger('warn', e);\n        }\n\n        return outputData;\n    }\n\n    private async processNode(node: EngineNode) {\n        if (this.state === State.ABORT || !node)\n            return null;\n        \n        await this.lock(node);\n\n        if (!node.outputData) {\n            node.outputData = this.processWorker(node)\n        }\n\n        this.unlock(node);\n        return node.outputData;\n    }\n\n    private async forwardProcess(node: Node) {\n        if (this.state === State.ABORT)\n            return null;\n\n        return await Promise.all(Object.keys(node.outputs).map(async (key) => {\n            const output = node.outputs[key];\n            \n            return await Promise.all(output.connections.map(async (c) => {\n                const nextNode = (this.data as Data).nodes[c.node];\n\n                await this.processNode(nextNode as EngineNode);\n                await this.forwardProcess(nextNode);\n            }));\n        }));\n    }\n\n    copy(data: Data) {\n        data = Object.assign({}, data);\n        data.nodes = Object.assign({}, data.nodes);\n        \n        Object.keys(data.nodes).forEach(key => {\n            data.nodes[key] = Object.assign({}, data.nodes[key])\n        });\n        return data;\n    }\n\n    async validate(data: Data) {\n        const checking = Validator.validate(this.id, data);\n        const recursion = new Recursion(data.nodes);\n\n        if (!checking.success)\n            return await this.throwError(checking.msg);  \n        \n        const recurrentNode = recursion.detect();\n\n        if (recurrentNode)\n            return await this.throwError('Recursion detected', recurrentNode);      \n         \n        return true;\n    }\n\n    private async processStartNode(id: string | number | null) {\n        if (!id) return;\n\n        let startNode = (this.data as Data).nodes[id];\n\n        if (!startNode)\n            return await this.throwError('Node with such id not found');   \n        \n        await this.processNode(startNode as EngineNode);\n        await this.forwardProcess(startNode);\n    }\n\n    private async processUnreachable() {\n        const data = this.data as Data;\n\n        for (let i in data.nodes) { // process nodes that have not been reached\n            const node = data.nodes[i] as EngineNode;\n\n            if (typeof node.outputData === 'undefined') {\n                await this.processNode(node);\n                await this.forwardProcess(node);\n            }\n        }\n    }\n\n    async process(data: Data, startId: number | string | null = null, ...args: []) {\n        if (!this.processStart()) return;\n        if (!this.validate(data)) return;    \n        \n        this.data = this.copy(data);\n        this.args = args;\n        \n        await this.processStartNode(startId);\n        await this.processUnreachable();\n        \n        return this.processDone()?'success':'aborted';\n    }\n}","import { Component } from './component';\nimport { Connection } from './connection';\nimport { Control } from './control';\nimport { Emitter } from './core/emitter';\nimport { IO } from './io';\nimport { Input } from './input';\nimport { Node } from './node';\nimport { NodeEditor } from './editor';\nimport { Output } from './output';\nimport { Socket } from './socket';\nimport { Engine, Recursion } from './engine/index';\n\nexport { Engine, Recursion } from './engine/index';\nexport { Component } from './component';\nexport { Control } from './control';\nexport { Connection } from './connection';\nexport { Emitter } from './core/emitter';\nexport { Input } from './input';\nexport { IO } from './io';\nexport { Node } from './node';\nexport { NodeEditor } from './editor';\nexport { Output } from './output';\nexport { Socket } from './socket';\n\nexport default {\n    Engine,\n    Recursion,\n    Component,\n    Control,\n    Connection,\n    Emitter,\n    Input,\n    IO,\n    Node,\n    NodeEditor,\n    Output,\n    Socket\n}"],"names":["Component","name","Node","Map","id","incrementId","list","item","prop","has","key","Error","this","set","control","_add","controls","parent","input","inputs","removeConnections","node","output","outputs","values","reduce","arr","io","connections","reduceIO","Array","from","obj","toJSON","data","position","latestId","json","x","y","Math","max","ComponentWorker","builder","build","Connection","addConnection","removeConnection","Control","constructor","TypeError","getNode","Emitter","events","handlers","names","handler","split","forEach","_this","push","params","r","e","isArray","IO","socket","multiConns","multipleConnections","connection","splice","indexOf","map","Input","title","length","hasConnection","c","Validator","isValidId","nodes","Object","test","id1","id2","msg","isValidData","success","Boolean","join","Context","plugins","components","plugin","options","install","component","trigger","Drag","el","onTranslate","onStart","onDrag","pointerStart","initEvents","style","touchAction","addEventListener","down","bind","window","move","up","stopPropagation","pageX","pageY","preventDefault","delta","zoom","getBoundingClientRect","width","offsetWidth","Zoom","container","intensity","onzoom","distance","wheel","end","dblclick","rect","wheelDelta","deltaY","ox","left","clientX","oy","top","clientY","touches","x1","y1","x2","y2","cx","cy","sqrt","pow","Area","emitter","k","document","createElement","transformOrigin","onZoom","pointermove","update","t","transform","mouse","_startPosition","dx","dy","translate","source","d","appendChild","removeChild","ConnectionView","inputNode","outputNode","zIndex","points","getPoints","getSocketPosition","ControlView","SocketView","type","offsetLeft","offsetTop","offsetHeight","NodeView","onSelect","bindSocket","bindControl","ios","sockets","s","includes","_this2","clearSockets","get","getPosition","accumulate","ctrlKey","prev","EditorView","overflow","click","view","resize","on","updateConnections","area","nodeView","viewInput","viewOutput","connView","getConnections","conn","parentElement","clientWidth","height","clientHeight","target","Selected","contains","callback","Events","warn","console","error","componentregister","destroy","EditorEvents","nodecreate","nodecreated","noderemove","noderemoved","connectioncreate","connectioncreated","connectionremove","connectionremoved","translatenode","nodetranslate","nodetranslated","nodedraged","selectnode","nodeselect","nodeselected","rendernode","rendersocket","rendercontrol","renderconnection","updateconnection","keydown","keyup","translated","zoomed","mousemove","contextmenu","process","NodeEditor","selectNode","selected","each","n","addNode","removeNode","connectTo","remove","add","editor","_this3","checking","validate","silent","clear","beforeImport","Promise","all","keys","_this4","getComponent","fromJSON","jsonNode","jsonConnection","nodeId","targetOutput","targetInput","connect","afterImport","Output","compatibleWith","some","Socket","compatible","Recursion","a","b","inputNodes","inters","array1","array2","filter","value","intersect","l","inter","findSelf","extractInputNodes","nodesArr","State","EngineEvents","Engine","engine","register","message","abort","processDone","state","onAbort","ret","res","unlockPool","busy","outputData","conns","prevNode","processNode","connData","extractInputData","inputData","worker","args","lock","processWorker","unlock","nextNode","forwardProcess","assign","recursion","throwError","recurrentNode","detect","startNode","i","startId","processStart","copy","processStartNode","processUnreachable"],"mappings":"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"}